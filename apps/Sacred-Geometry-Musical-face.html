<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sacred Geometry Music | Keys, Codes & Modes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at center, #0a0a1f 0%, #000000 100%);
            color: #e0e0e0;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            padding: 30px 20px 20px;
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }

        .hero-logo {
            font-size: 3em;
            font-weight: bold;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6B6B, #9370DB);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: 3px;
        }

        .tagline {
            font-size: 1.3em;
            color: #FFD700;
            font-style: italic;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1em;
            color: #a0a0a0;
        }

        .main-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 2000px;
            margin: 0 auto;
        }

        .visualization-area {
            flex: 1;
            min-width: 800px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .canvas-title {
            text-align: center;
            font-size: 1.8em;
            color: #FFD700;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #mainCanvas {
            width: 100%;
            height: 700px;
            border-radius: 10px;
            cursor: grab;
            display: block;
        }

        #mainCanvas:active {
            cursor: grabbing;
        }

        .controls-panel {
            width: 400px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            max-height: 900px;
            overflow-y: auto;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .mode-buttons {
            display: grid;
            gap: 10px;
        }

        button {
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 25px rgba(102, 126, 234, 0.5);
        }

        button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 5px 25px rgba(245, 87, 108, 0.5);
        }

        .note-display {
            text-align: center;
            font-size: 4em;
            color: #FFD700;
            margin: 20px 0;
            min-height: 80px;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        .note-display.playing {
            animation: pulse 0.3s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        .info-box {
            background: rgba(255, 215, 0, 0.05);
            border-left: 4px solid #FFD700;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .info-box h4 {
            color: #FFD700;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .info-box p {
            color: #c0c0c0;
            line-height: 1.6;
            font-size: 0.95em;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-item label {
            display: block;
            color: #a0a0a0;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 4px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .instructions {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .instructions h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .audio-status {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #FFD700;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .audio-status.ready {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        .test-button {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #000;
            font-size: 1.1em;
            padding: 12px 30px;
            margin: 5px;
        }

        .toggle-button {
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            color: #000;
            font-size: 1em;
            padding: 10px 20px;
            margin: 5px;
        }

        .toggle-button.off {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="hero-logo">Keys, Codes & Modes</div>
        <div class="tagline">A Visual Approach to Understanding Music</div>
        <div class="subtitle">Interactive Sacred Geometry Music Explorer</div>
    </div>

    <div class="main-container">
        <div class="visualization-area">
            <div class="audio-status" id="audioStatus">
                <h4 id="statusTitle">üîä Click anywhere to enable audio</h4>
                <button class="test-button" onclick="testAudio()">üéµ Test Audio (Play C note)</button>
            </div>

            <div class="canvas-container">
                <div class="canvas-title">Sacred Geometry Musical Interface</div>
                <div class="note-display" id="noteDisplay">Click a face to play</div>
                <canvas id="mainCanvas"></canvas>
            </div>

            <div class="instructions">
                <h4>üéµ How to Play & Control</h4>
                <p><strong>üñ±Ô∏è DRAG with mouse</strong> to rotate the shape freely<br>
                <strong>üñ±Ô∏è CLICK on faces</strong> to hear musical notes<br>
                <strong>üñ±Ô∏è SCROLL</strong> to zoom in/out<br>
                <strong>Toggle Auto-Rotation</strong> on/off with button below</p>
            </div>
        </div>

        <div class="controls-panel">
            <div class="control-section">
                <h3>üî∑ Platonic Solids</h3>
                <div class="mode-buttons">
                    <button id="btn-tetrahedron" onclick="changeMode('tetrahedron')">üî∫ Tetrahedron (4 Faces)</button>
                    <button id="btn-cube" onclick="changeMode('cube')">‚¨õ Cube (6 Faces)</button>
                    <button id="btn-octahedron" onclick="changeMode('octahedron')">üíé Octahedron (8 Faces)</button>
                    <button id="btn-dodecahedron" onclick="changeMode('dodecahedron')" class="active">‚¨¢ Dodecahedron (12 Faces)</button>
                    <button id="btn-icosahedron" onclick="changeMode('icosahedron')">üî∑ Icosahedron (20 Faces)</button>
                </div>
            </div>

            <div class="control-section">
                <h3>‚öôÔ∏è Mouse Controls</h3>
                <button id="autoRotateBtn" class="toggle-button" onclick="toggleAutoRotate()">üîÑ Auto-Rotate: ON</button>
                <button class="toggle-button" onclick="resetView()">üîÑ Reset View</button>
                
                <div class="control-item" style="margin-top: 15px;">
                    <label>Auto-Rotation Speed: <span id="autoSpeedValue">30</span></label>
                    <input type="range" id="autoSpeed" min="0" max="100" value="30" oninput="updateAutoSpeed()">
                </div>
                <div class="control-item">
                    <label>Mouse Sensitivity: <span id="sensitivityValue">1.0</span></label>
                    <input type="range" id="sensitivity" min="0.1" max="3" value="1" step="0.1" oninput="updateSensitivity()">
                </div>
                <div class="control-item">
                    <label>Camera Distance: <span id="zoomValue">5</span></label>
                    <input type="range" id="zoom" min="3" max="10" value="5" step="0.1" oninput="updateControls()">
                </div>
            </div>

            <div class="control-section">
                <h3>üé® Chromatic Color Map</h3>
                <div id="colorLegend"></div>
            </div>

            <div class="control-section">
                <div class="info-box">
                    <div id="mainInfo"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, currentMesh;
        let currentMode = 'dodecahedron';
        let audioContext = null;
        let raycaster, mouse;
        let audioReady = false;

        // Mouse control variables
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let autoRotate = true;
        let autoRotateSpeed = 0.003;
        let mouseSensitivity = 1.0;
        let damping = 0.95; // For smooth rotation decay

        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        const chromaticColors = {
            'C': 0xff0000,   'C#': 0xff4500,  'D': 0xff8c00,   'D#': 0xffd700,
            'E': 0xffff00,   'F': 0x9acd32,   'F#': 0x00ff00,  'G': 0x00ffff,
            'G#': 0x1e90ff,  'A': 0x0000ff,   'A#': 0x8b00ff,  'B': 0xff00ff
        };

        const solidMappings = {
            tetrahedron: ['C', 'E', 'G', 'B'],
            cube: ['C', 'D', 'E', 'F#', 'G#', 'A#'],
            octahedron: ['C', 'D', 'D#', 'F', 'F#', 'G#', 'A', 'B'],
            dodecahedron: noteNames,
            icosahedron: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G']
        };

        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(() => {
                            audioReady = true;
                            updateAudioStatus();
                        });
                    } else {
                        audioReady = true;
                        updateAudioStatus();
                    }
                } catch(e) {
                    console.error('Error creating AudioContext:', e);
                }
            } else if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    audioReady = true;
                    updateAudioStatus();
                });
            }
        }

        function updateAudioStatus() {
            const status = document.getElementById('audioStatus');
            const title = document.getElementById('statusTitle');
            if (audioReady) {
                status.classList.add('ready');
                title.textContent = '‚úÖ Audio Ready! Drag to rotate, click faces to play notes';
            }
        }

        function testAudio() {
            initAudio();
            setTimeout(() => {
                playNote('C');
            }, 100);
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('autoRotateBtn');
            if (autoRotate) {
                btn.textContent = 'üîÑ Auto-Rotate: ON';
                btn.classList.remove('off');
            } else {
                btn.textContent = 'üîÑ Auto-Rotate: OFF';
                btn.classList.add('off');
            }
        }

        function resetView() {
            if (currentMesh) {
                currentMesh.rotation.x = 0;
                currentMesh.rotation.y = 0;
                currentMesh.rotation.z = 0;
                rotationVelocity = { x: 0, y: 0 };
            }
            camera.position.z = 5;
            document.getElementById('zoom').value = 5;
            document.getElementById('zoomValue').textContent = '5';
        }

        function updateAutoSpeed() {
            const speed = parseFloat(document.getElementById('autoSpeed').value);
            autoRotateSpeed = speed * 0.0001;
            document.getElementById('autoSpeedValue').textContent = speed;
        }

        function updateSensitivity() {
            mouseSensitivity = parseFloat(document.getElementById('sensitivity').value);
            document.getElementById('sensitivityValue').textContent = mouseSensitivity.toFixed(1);
        }

        function init() {
            if (typeof THREE === 'undefined') {
                setTimeout(init, 100);
                return;
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            const canvas = document.getElementById('mainCanvas');
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight1 = new THREE.PointLight(0xffffff, 0.8);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);
            
            // Mouse event listeners for dragging
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            canvas.addEventListener('click', onCanvasClick);
            canvas.addEventListener('wheel', onWheel);
            
            // Touch support for mobile
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);
            
            document.addEventListener('click', function initOnClick() {
                initAudio();
            }, { once: false });
            
            window.addEventListener('resize', onWindowResize);
            
            createColorLegend();
            createGeometry('dodecahedron');
            updateInfo('dodecahedron');
            animate();
        }

        function onMouseDown(event) {
            isDragging = true;
            autoRotate = false;
            document.getElementById('autoRotateBtn').textContent = 'üîÑ Auto-Rotate: OFF';
            document.getElementById('autoRotateBtn').classList.add('off');
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                rotationVelocity.y = deltaMove.x * 0.005 * mouseSensitivity;
                rotationVelocity.x = deltaMove.y * 0.005 * mouseSensitivity;

                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
            
            // Update raycaster for hover effects
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / canvas.clientWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / canvas.clientHeight) * 2 + 1;

            if (!isDragging) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(currentMesh.children, true);
                
                let foundFace = false;
                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.userData.note) {
                        foundFace = true;
                        break;
                    }
                }
                canvas.style.cursor = foundFace ? 'pointer' : 'grab';
            }
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onWheel(event) {
            event.preventDefault();
            const delta = event.deltaY * -0.01;
            camera.position.z = Math.max(3, Math.min(10, camera.position.z - delta * 0.5));
            document.getElementById('zoom').value = camera.position.z;
            document.getElementById('zoomValue').textContent = camera.position.z.toFixed(1);
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1 && isDragging) {
                event.preventDefault();
                const deltaMove = {
                    x: event.touches[0].clientX - previousMousePosition.x,
                    y: event.touches[0].clientY - previousMousePosition.y
                };

                rotationVelocity.y = deltaMove.x * 0.005 * mouseSensitivity;
                rotationVelocity.x = deltaMove.y * 0.005 * mouseSensitivity;

                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        }

        function onTouchEnd(event) {
            isDragging = false;
        }

        function createGeometry(mode) {
            if (currentMesh) {
                scene.remove(currentMesh);
            }

            const notes = solidMappings[mode];
            let geometry;

            switch(mode) {
                case 'tetrahedron':
                    geometry = new THREE.TetrahedronGeometry(2.5);
                    break;
                case 'cube':
                    geometry = new THREE.BoxGeometry(2.5, 2.5, 2.5);
                    break;
                case 'octahedron':
                    geometry = new THREE.OctahedronGeometry(2.5);
                    break;
                case 'dodecahedron':
                    geometry = new THREE.DodecahedronGeometry(2.5);
                    break;
                case 'icosahedron':
                    geometry = new THREE.IcosahedronGeometry(2.5);
                    break;
            }

            const group = new THREE.Group();
            const positionAttribute = geometry.attributes.position;
            const indexAttribute = geometry.index;
            
            const faces = [];
            const faceCount = indexAttribute ? indexAttribute.count / 3 : positionAttribute.count / 3;
            
            for (let i = 0; i < faceCount; i++) {
                const vertices = [];
                
                for (let j = 0; j < 3; j++) {
                    const idx = indexAttribute ? indexAttribute.getX(i * 3 + j) : i * 3 + j;
                    vertices.push(new THREE.Vector3(
                        positionAttribute.getX(idx),
                        positionAttribute.getY(idx),
                        positionAttribute.getZ(idx)
                    ));
                }
                
                faces.push({ vertices, index: i });
            }

            const facesPerNote = Math.max(1, Math.floor(faces.length / notes.length));
            
            faces.forEach((face, faceIdx) => {
                const noteIndex = Math.floor(faceIdx / facesPerNote);
                const note = notes[Math.min(noteIndex, notes.length - 1)];
                const color = chromaticColors[note];
                
                const faceGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(9);
                
                face.vertices.forEach((v, i) => {
                    positions[i * 3] = v.x;
                    positions[i * 3 + 1] = v.y;
                    positions[i * 3 + 2] = v.z;
                });
                
                faceGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                faceGeometry.computeVertexNormals();
                
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    shininess: 100,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(faceGeometry, material);
                mesh.userData.note = note;
                mesh.userData.color = color;
                group.add(mesh);
            });

            const edges = new THREE.EdgesGeometry(geometry);
            const wireframe = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true })
            );
            group.add(wireframe);

            currentMesh = group;
            scene.add(currentMesh);
        }

        function onCanvasClick(event) {
            // Only play sound if we didn't just finish dragging
            if (Math.abs(rotationVelocity.x) > 0.01 || Math.abs(rotationVelocity.y) > 0.01) {
                return;
            }

            initAudio();
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            
            mouse.x = ((event.clientX - rect.left) / canvas.clientWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / canvas.clientHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(currentMesh.children, true);

            if (intersects.length > 0) {
                for (let i = 0; i < intersects.length; i++) {
                    const object = intersects[i].object;
                    
                    if (object.userData.note && object.type === 'Mesh') {
                        const note = object.userData.note;
                        
                        playNote(note);
                        flashFace(object);
                        
                        const display = document.getElementById('noteDisplay');
                        display.textContent = note;
                        display.classList.remove('playing');
                        void display.offsetWidth;
                        display.classList.add('playing');
                        
                        break;
                    }
                }
            }
        }

        function flashFace(mesh) {
            const originalIntensity = mesh.material.emissiveIntensity;
            mesh.material.emissiveIntensity = 1.0;
            
            setTimeout(() => {
                mesh.material.emissiveIntensity = originalIntensity;
            }, 400);
        }

        function playNote(noteName) {
            if (!audioContext) {
                initAudio();
                setTimeout(() => playNote(noteName), 200);
                return;
            }

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    playNote(noteName);
                });
                return;
            }

            try {
                const noteIndex = noteNames.indexOf(noteName);
                const frequency = 261.63 * Math.pow(2, noteIndex / 12);

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';

                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.8);

                oscillator.start(now);
                oscillator.stop(now + 0.8);
            } catch(e) {
                console.error('Error playing note:', e);
            }
        }

        function changeMode(mode) {
            currentMode = mode;
            createGeometry(mode);
            updateInfo(mode);
            
            document.querySelectorAll('.mode-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('btn-' + mode).classList.add('active');
        }

        function updateInfo(mode) {
            const info = {
                tetrahedron: {
                    title: 'Tetrahedron - Fire Element',
                    details: `<strong>Faces:</strong> 4 triangular faces<br>
                             <strong>Notes:</strong> C, E, G, B<br>
                             <strong>Element:</strong> Fire - dynamic energy`
                },
                cube: {
                    title: 'Cube - Earth Element',
                    details: `<strong>Faces:</strong> 6 square faces<br>
                             <strong>Notes:</strong> C, D, E, F#, G#, A#<br>
                             <strong>Element:</strong> Earth - stability`
                },
                octahedron: {
                    title: 'Octahedron - Air Element',
                    details: `<strong>Faces:</strong> 8 triangular faces<br>
                             <strong>Notes:</strong> Octatonic scale<br>
                             <strong>Element:</strong> Air - balance`
                },
                dodecahedron: {
                    title: 'Dodecahedron - Ether Element',
                    details: `<strong>Faces:</strong> 12 pentagonal faces<br>
                             <strong>Notes:</strong> Complete chromatic scale!<br>
                             <strong>Element:</strong> Ether - universe`
                },
                icosahedron: {
                    title: 'Icosahedron - Water Element',
                    details: `<strong>Faces:</strong> 20 triangular faces<br>
                             <strong>Notes:</strong> Chromatic patterns<br>
                             <strong>Element:</strong> Water - fluidity`
                }
            };

            const data = info[mode];
            document.getElementById('mainInfo').innerHTML = `<h4>${data.title}</h4><p>${data.details}</p>`;
        }

        function updateControls() {
            camera.position.z = parseFloat(document.getElementById('zoom').value);
            document.getElementById('zoomValue').textContent = camera.position.z.toFixed(1);
        }

        function createColorLegend() {
            const legend = document.getElementById('colorLegend');
            noteNames.forEach(note => {
                const item = document.createElement('div');
                item.className = 'legend-item';

                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = '#' + chromaticColors[note].toString(16).padStart(6, '0');

                const label = document.createElement('span');
                label.textContent = note;

                item.appendChild(colorBox);
                item.appendChild(label);
                legend.appendChild(item);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (currentMesh) {
                // Apply rotation from mouse drag
                if (!isDragging) {
                    currentMesh.rotation.x += rotationVelocity.x;
                    currentMesh.rotation.y += rotationVelocity.y;
                    
                    // Apply damping for smooth deceleration
                    rotationVelocity.x *= damping;
                    rotationVelocity.y *= damping;
                }
                
                // Add auto-rotation if enabled
                if (autoRotate && !isDragging) {
                    currentMesh.rotation.x += autoRotateSpeed;
                    currentMesh.rotation.y += autoRotateSpeed;
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const canvas = document.getElementById('mainCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        window.onload = init;
    </script>
</body>
</html>
